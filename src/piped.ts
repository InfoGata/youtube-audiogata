import ky from "ky";
import { storage, StorageType } from "./shared";
const defaultInstace = "https://piped.kavin.rocks";

interface PipedApiResponse {
  videoStreams: PipedApiVideoStream[];
  title: string;
  description: string;
  duration: number;
  hls: string;
  dislikes: number;
  likes: number;
  // YYYY-MM-DD
  uploadDate: string;
  uploader: string;
  uploaderUrl: string;
  views: number;
  relatedStreams: PipedRelatedStream[];
  audioStreams: PipedAudioStream[];
  dash: string | null;
  lbryId: string;
  livestream: boolean;
  proxyUrl: string;
  subtitles: PipedSubtitle[];
  thumbnailUrl: string;
  uploaderVerified: boolean;
}

interface PipedAudioStream {
  bitrate: number;
  codec: string;
  format: string;
  indexEnd: number;
  indexStart: number;
  initStart: number;
  initEnd: number;
  mimeType: string;
  quality: string;
  url: string;
  videoOnly: boolean;
}

interface PipedChannelVideos {
  avatarUrl: string;
  bannerUrl: string;
  description: string;
  id: string;
  name: string;
  nextpage: string;
  relatedStreams: PipedRelatedStream[];
}

interface PipedChannelVideoNextPage {
  nextpage: string;
  relatedStreams: PipedRelatedStream[];
}

interface PipedPlaylistVideos {
  bannerUrl: string;
  name: string;
  nextpage: string;
  relatedStreams: PipedRelatedStream[];
  thumbnailUrl: string;
  uploader: string;
  uploaderAvatar: string;
  uploaderUrl: string;
  videos: number;
}

interface PipedSubtitle {
  autoGenerated: boolean;
  code: string;
  mimeType: string;
  name: string;
  url: string;
}

interface PipedRelatedStream {
  duration: number;
  uploaderName: string;
  uploaderUrl?: string;
  thumbnail: string;
  title: string;
  url: string;
  views: number;
  uploadedDate: string;
  uploaderAvatar: string;
  uploaderVerified: boolean;
}

interface PipedApiVideoStream {
  format: string;
  url: string;
  bitrate: number;
}

interface PipedInstance {
  name: string;
  api_url: string;
  version: string;
  up_to_date: boolean;
  cdn: boolean;
  registered: number;
  last_checked: number;
  uptime_24h: number;
  uptime_7d: number;
  uptime_30d: number;
}

interface PipedComments {
  author: string;
  commentId: string;
  commentText: string;
  commentedTtime: string;
  commentorUrl: string;
  hearted: boolean;
  likeCount: number;
  pinned: boolean;
  verified: boolean;
  creatorReplied: boolean;
  thumbnail: string;
}

interface PipedCommentsResponse {
  disabled: boolean;
  nextpage: string;
  comments: PipedComments[];
}

interface PipedChannelResponse {
  avatarUrl: string;
  bannerUrl: string;
  description: string;
  id: string;
  name: string;
  nextpage: string;
  relatedStreams: PipedRelatedStream[];
  subscriberCount: number;
  verified: boolean;
}

interface PipedPlaylistResponse {
  bannerUrl: string;
  name: string;
  nextpage: string;
  relatedStreams: PipedRelatedStream[];
  thumbnailUrl: string;
  uploader: string;
  uploaderAvatar: string;
  uploaderUrl: string;
  videos: number;
}

interface PipedSearchResponse {
  items: (PipedChannelSearchItem | PipedVideoSearchItem | PipedPlaylistSearchItem)[];
  nextpage: string;
  suggestion: string;
  corrected: boolean;
}

interface PipedChannelSearchItem {
  type: "channel";
  // url is /channel/{channelApiId}
  url: string;
  name: string;
  thumbnail: string;
  description: string;
  subscribers: number;
  videos: number;
  verified: boolean;
}

interface PipedVideoSearchItem {
  type: "stream";
  // url is /watch?v={videoApiId}
  url: string;
  title: string;
  thumbnail: string;
  uploaderName: string;
  uploaderUrl: string;
  uploaderAvatar: string;
  uploadedDate: string;
  shortDescription: string;
  duration: number;
  views: number;
  uploaded: number;
  uploaderVerified: boolean;
  isShort: boolean;
}

interface PipedPlaylistSearchItem {
  type: "playlist";
  // url is /watch?v={playlistApiId}
  url: string;
  name: string;
  thumbnail: string;
  uploaderName: string;
  uploaderUrl: string;
  uploaderVerified: boolean;
  playlistType: string;
  videos: number;
}
 
interface PipedSearchSuggestionsResponse {
  0: string;
  1: string[];
}

const relatedStreamToVideo = (stream: PipedRelatedStream): Track => ({
  name: stream.title,
  apiId: stream.url.split("=").slice(-1)[0],
  images: [{ url: stream.thumbnail }],
  duration: stream.duration,
});

export const fetchInstances = async () => {
  const instancesUrl = "https://piped-instances.kavin.rocks/";
  const instances = await ky.get<PipedInstance[]>(instancesUrl).json();
  storage.setItem(StorageType.PipedInstances, JSON.stringify(instances));
  return instances;
};

export const getInstance = async (): Promise<string> => {
  const instanceString = storage.getItem(StorageType.PipedInstances);
  let instances: PipedInstance[] = [];
  if (instanceString) {
    instances = JSON.parse(instanceString);
  } else {
    try {
      instances = await fetchInstances();
    } catch (err) {
      console.error(err);
      return defaultInstace;
    }
  }
  const newInstance = instances[0].api_url;

  storage.setItem(StorageType.PipedCurrentInstance, newInstance);
  return newInstance;
};

const getAllInstances = async (): Promise<PipedInstance[]> => {
  const instanceString = storage.getItem(StorageType.PipedInstances);
  if (instanceString) {
    return JSON.parse(instanceString);
  }
  return await fetchInstances();
};

export const getCurrentInstance = async (): Promise<string> => {
  let instance = storage.getItem(StorageType.PipedCurrentInstance);
  if (!instance) {
    instance = await getInstance();
  }
  return instance;
};

export async function getYoutubeTrackPiped(
  track: GetTrackUrlRequest,
  instanceIndex = 0
): Promise<string> {
  const instances = await getAllInstances();
  let instance = await getCurrentInstance();
  if (instanceIndex > 0 && instanceIndex < instances.length) {
    instance = instances[instanceIndex].api_url;
  }
  try {
    const url = `${instance}/streams/${track.apiId}`;
    const timeoutMs = 10000;
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => reject(), timeoutMs);
    });
    const responsePromise = ky.get<PipedApiResponse>(url).json();
    await Promise.race([responsePromise, timeoutPromise]);

    const response = await responsePromise;
    const sortedArray = response.audioStreams.sort(
      (a, b) => b.bitrate - a.bitrate
    );
    const youtubeUrl = sortedArray[0].url;
    return youtubeUrl;
  } catch (err) {
    const instances = await getAllInstances();
    if (instanceIndex < instances.length) {
      return getYoutubeTrackPiped(track, instanceIndex + 1);
    }
    throw err;
  }
}

export const getTrackByApiIdPiped = async (track: GetTrackUrlRequest): Promise<Track> => {
  const instance = await getCurrentInstance();
  const url = `${instance}/streams/${track.apiId}`;
  const response = await ky.get<PipedApiResponse>(url).json();
  return {
    name: response.title,
    apiId: track.apiId,
    images: [{ url: response.thumbnailUrl }],
    duration: response.duration,
  }
}

export const searchTracksPiped = async (request: SearchRequest): Promise<SearchTrackResult> => {
  const instance = await getCurrentInstance();
  const url = `${instance}/search?q=${request.query}&filter=videos`;
  const response = await ky.get<PipedSearchResponse>(url).json();
  const items = response.items
    .filter((item): item is PipedVideoSearchItem => item.type === "stream")
    .map((item): Track => {
      return {
        name: item.title,
        apiId: item.url.split("=").slice(-1)[0],
        images: [{ url: item.thumbnail }],
        duration: item.duration,
      }
  });
  const pageInfo: PageInfo = {
    resultsPerPage: 0,
    offset: 0,
    nextPage: response.nextpage,
  }
  return {
    items,
    pageInfo,
  }
}

export const searchPlaylistsPiped = async (request: SearchRequest): Promise<SearchPlaylistResult> => {
  const instance = await getCurrentInstance();
  const url = `${instance}/search?q=${request.query}&filter=playlists`;
  const response = await ky.get<PipedSearchResponse>(url).json();
  const items = response.items.filter((item): item is PipedPlaylistSearchItem => item.type === "playlist").map((item): Playlist => {
    return {
      name: item.name,
      apiId: item.url.split("=").slice(-1)[0],
      images: [{ url: item.thumbnail }],
      tracks: [],
    }
  })
  const pageInfo: PageInfo = {
    resultsPerPage: 0,
    offset: 0,
    nextPage: response.nextpage,
  }
  return {
    items,
    pageInfo,
  }
}

export const getPlaylistTracksPiped = async (request: PlaylistTrackRequest): Promise<PlaylistTracksResult> => {
  const instance = await getCurrentInstance();
  const url = `${instance}/playlists/${request.apiId}`;
  const response = await ky.get<PipedPlaylistVideos>(url).json();
  const videos = response.relatedStreams.map(relatedStreamToVideo);
  const pageInfo: PageInfo = {
    resultsPerPage: 0,
    offset: 0,
    nextPage: response.nextpage,
  }
  return {
    items: videos,
    pageInfo,
  }
}

export const onGetPipedSearchSuggestions = async (request: GetSearchSuggestionsRequest): Promise<string[]> => {
  const instance = await getCurrentInstance();
  const url = `${instance}/opensearch/suggestions?query=${request.query}`;
  const response = await ky.get<PipedSearchSuggestionsResponse>(url).json();
  return response[1];
};